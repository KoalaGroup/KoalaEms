/*
 * lowlevel/jtag_low.c
 * created 12.Aug.2005 PW
 * $ZEL$
 */

#include <sconf.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <strings.h>
#include "../devices.h"
#include "jtag_low.h"
#include "jtag_int.h"

#ifdef LOWLEVEL_UNIXVME
#include "../unixvme/vme.h"
#endif
#ifdef LOWLEVEL_LVD
#include "../lvd/lvdbus.h"
#endif

#define __CONCAT(x,y)	x ## y
#define __STRING(x)	#x
#define __SS(s) __STRING(s)
#define JTAG_DEV(vendor, name, ir_len, mem_size) { \
    __CONCAT(VID_, vendor),                        \
    __CONCAT(DID_, name),                          \
    ir_len,                                        \
    mem_size,                                      \
    __SS(name)                                     \
}
#define JTAG_DEV_END(name) {                       \
    0, 0, -1, -1, __SS(name)                       \
}

static const struct jtag_chipdata jtag_chipdata[]={
    JTAG_DEV(XILINX, XC18V01 , 8, 0x20000),
    JTAG_DEV(XILINX, XC18V02 , 8, 0x40000),
    JTAG_DEV(XILINX, XC18V04a, 8, 0x80000),
    JTAG_DEV(XILINX, XC18V04b, 8, 0x80000),
    JTAG_DEV(XILINX, XC2V2000, 6, -1),
    JTAG_DEV(XILINX, XC3S200 , 6, -1),
    JTAG_DEV(XILINX, XCF01S  , 8, -1),
    JTAG_DEV(XILINX, XCV150  , 5, -1),
    JTAG_DEV(XILINX, XCV300  , 5, -1),
    JTAG_DEV(XILINX, XCV400  , 5, -1),
    JTAG_DEV_END(unknown device),
};

static enum jtag_states jtag_transitions[][2]={
    /*jtag_TLR*/ {jtag_RTI, jtag_TLR},
    /*jtag_RTI*/ {jtag_RTI, jtag_SDS},
    /*jtag_SDS*/ {jtag_CD , jtag_SIS},
    /*jtag_CD */ {jtag_SD , jtag_E1D},
    /*jtag_SD */ {jtag_SD , jtag_E1D},
    /*jtag_E1D*/ {jtag_PD , jtag_UD},
    /*jtag_PD */ {jtag_PD , jtag_E2D},
    /*jtag_E2D*/ {jtag_SD , jtag_UD},
    /*jtag_UD */ {jtag_RTI, jtag_SDS},
    /*jtag_SIS*/ {jtag_CI , jtag_TLR},
    /*jtag_CI */ {jtag_SI , jtag_E1I},
    /*jtag_SI */ {jtag_SI , jtag_E1I},
    /*jtag_E1I*/ {jtag_PI , jtag_UI},
    /*jtag_PI */ {jtag_PI , jtag_E2I},
    /*jtag_E2I*/ {jtag_SI , jtag_UI},
    /*jtag_UI */ {jtag_RTI, jtag_SDS},
};
/*
static const char* jtag_state_names[]={
    "test-logic-reset",
    "run-test/idle",
    "select-dr-scan",
    "capture-dr",
    "shift-dr",
    "exit1-dr",
    "pause-dr",
    "exit2-dr",
    "update-dr",
    "select-ir-scan",
    "capture-ir",
    "shift-ir",
    "exit1-ir",
    "pause-ir",
    "exit2-ir",
    "update-ir",
};
*/

static int tdo_=0;

/****************************************************************************/
static void
printbits32(ems_u32 d, const char* as, const char* es)
{
    int i;

    printf("%s", as);
    for (i=0; i<32; i++) {
        int bit=!!(d&0x80000000UL);
        printf("%d", bit);
        if (i%4==3)
            printf(" ");
        d<<=1;
    }
    printf("%s", es);
}
/****************************************************************************/
static void
changestate(struct jtag_chain* chain, int tms)
{
    enum jtag_states oldstate;

    if ((tms<0) || (tms>1)) {
        printf("changestate: invalid ms: %d\n", tms);
        return;
    }
    oldstate=chain->jstate;
    chain->jstate=jtag_transitions[oldstate][tms];
}
/****************************************************************************/
#if 0
static void
jtag_action(struct jtag_chain* chain, int tms, int tdi)
{
    struct jtag_dev* jdev=&chain->jtag_dev;
/*
    int tms, tdi;
    tms=!!(v&TMS);
    tdi=!!(v&TDI);
*/
    jdev->jt_action(jdev, tms, tdi, &tdo_);
    tdo_=!!tdo_;
    changestate(chain, tms);
/*
    printf("tms %d tdi %d tdo %d %s\n", tms, tdi, tdo_,
        jtag_state_names[chain->jstate]);
*/
}
#endif
/****************************************************************************/
static int
jt_getcsr(struct jtag_chain* chain, u_int32_t* v)
{
    *v=tdo_?TDO:0;
    return 0;
}
/****************************************************************************/
static int
jtag_action(struct jtag_chain* chain, int tms, int tdi, int* tdo)
{
    struct jtag_dev* jtag_dev=&chain->jtag_dev;
    int tdo__, res;
#if 0
    tdi=!!tdi;
#else
    tdi=tdi==1;
#endif

    res=jtag_dev->jt_action(jtag_dev, tms, tdi, &tdo__);
    if (tdo)
        *tdo=tdo__;
    tdo_=!!tdo__;
    changestate(chain, tms);
    return res;
}
/****************************************************************************/
static int
jtag_data(struct jtag_chain* chain, u_int32_t* d)
{
    struct jtag_dev* jdev=&chain->jtag_dev;
    jdev->jt_data(jdev, d);
    return 0;
}
/****************************************************************************/
static int
jtag_data32(struct jtag_chip* chip, u_int32_t din, u_int32_t* dout, int len)
{
    struct jtag_chain* chain=chip->chain;
    int i;

    printf("data32(in=%x len=%d)\n", din, len);

    jtag_action(chain, 1, 2, 0);
    jtag_action(chain, 0, 2, 0);
    jtag_action(chain, 0, 2, 0);			/* SHIFT-DR */

#if 0
instruction(icode=fe)
data32(in=ffffffff len=32)
tdo  0000 0101 0000 0010 0100 0000 1001 0011
data 0000 0101 0000 0010 0100 0000 1001 0011
instruction(icode=e8)
data32(in=34 len=6)
tdo  0000 0000 0000 0000 0000 0000 0000 0000
data 0000 0000 0000 0000 0000 0000 0000 0000
instruction(icode=eb)
data32(in=0 len=16)
tdo  0000 0000 0000 0000 1111 1111 1111 1111
data 0000 0000 0000 0000 1111 1111 1111 1111
instruction(icode=f8)
#endif

    /* shift pre_bits */
    for (i=chip->pre_d_bits; i>0; i--) {
        jtag_action(chain, 0, 2, 0);
    }

    /* shift len-1 data bits */
    for (i=len-1; i>0; i--) {
        jtag_action(chain, 0, din&1, 0);
        din>>=1;
    }
    /* read data */
    if (dout) {
        ems_u32 v;
        jtag_data(chain, &v);
        v>>=32-len;
        *dout=v;
        printbits32(v,  "data ", "\n");
    }

    /* if (after_bits>1): shift last data bit and after_bits-1 */
    for (i=chip->after_d_bits-1; i>=0; i--) {
        jtag_action(chain, 0, din&1, 0);   /* SD */
    }
    /* shift either last data bit or last afterbit */
    jtag_action(chain, 1, din&1, 0);       /* E1D */

    jtag_action(chain, 1, 2, 0);        /* UD */
    jtag_action(chain, 0, 2, 0);	/* state RTI */

    return 0;
}
/****************************************************************************/
static int
jtag_rd_data(struct jtag_chip* chip, void *buf, int len)
{
    struct jtag_chain* chain=chip->chain;
    int i, j, k;

    if (len == 0) {
        if (chain->state == 1) {
            jtag_action(chain, 1, 2, 0);
            jtag_action(chain, 1, 2, 0);
            jtag_action(chain, 0, 2, 0);
            chain->state=0;                          /* state RTI */
        }
        return 0;
    }

    if (chain->state == 0) {
        jtag_action(chain, 1, 2, 0);
        jtag_action(chain, 0, 2, 0);         /* CAPTURE-DR */

        for (i=chip->pre_d_bits; i>0; i--) {
            jtag_action(chain, 0, 1, 0);
        }
        chain->state=1;
    }

    for (i=(len+3)/4, k=0; i; i--, k++) {
        u_int32_t d;
        for (j=32; j; j--)
            jtag_action(chain, 0, 2, 0);
        jtag_data(chain, &d);
        *((u_int32_t*)buf)++ =d;
        if (k<10)
            printf("%08x\n", d);
    }
    return 0;
}
/****************************************************************************/
static int
jtag_instruction(struct jtag_chip* chip, u_int32_t icode, u_int32_t* ret)
{
    struct jtag_chain* chain=chip->chain;
    u_int32_t tdo, xtdo, ms, ms1;
    int i;

printf("instruction(icode=%x)\n", icode);
    jtag_action(chain, 1, 2, 0);
    jtag_action(chain, 1, 2, 0);
    jtag_action(chain, 0, 2, 0);
    jtag_action(chain, 0, 2, 0);

    for (i=chip->pre_c_bits; i>0; i--) {
        jtag_action(chain, 0, 1, 0);
    }
    ms=0; tdo=0; xtdo=1;
    ms1=chip->after_c_bits?0:1;
    for (i=chip->chipdata->ir_len-1; i>=0; i--) {
        ems_u32 v;
        jt_getcsr(chain, &v);
        tdo|=(v&TDO)?xtdo:0;
        xtdo<<=1;
        if (!i) ms=ms1;
        jtag_action(chain, ms, icode&1, 0);
        icode>>=1;
    }
    for (i=chip->after_c_bits-1; i>=0; i--) {
        if (!i) ms=1;
        jtag_action(chain, ms, 1, 0);
    }
    if (icode == CONFIG) { sleep(1); printf("2\n"); }

    jtag_action(chain, 1, 1, 0);
    if (icode == CONFIG) { sleep(1); printf("1\n"); }

    jtag_action(chain, 0, 1, 0);
    if (icode == CONFIG) { sleep(1); printf("0\n"); }

    if (ret)
        *ret=tdo;
    return 0;
}
/****************************************************************************/
int
jtag_read_XC18V00(struct jtag_chip* chip, void* data)
{
    struct jtag_chain* chain=chip->chain;
    u_int32_t dout, size;
    int ret, i;

    if (chain->state) {
        printf("chain.state=%d\n", chain->state);
        return -1;
    }

    printf("reading device %s\n", chip->chipdata->name);

    if (jtag_instruction(chip, IDCODE, 0)) {
        return -1;
    }
    if (jtag_data32(chip, -1, &dout, 32)<0)
        return -1;
    if ((dout&0x0fffffff)!=chip->id) {
        printf("wrong IDCODE: %08X\n", dout);
        return -1;
    }

    size=chip->chipdata->mem_size;

    jtag_instruction(chip, ISPEN, 0);
    jtag_data32(chip, 0x34, 0, 6);

    jtag_instruction(chip, FADDR, &ret);
    if (ret!=0x11) printf("FADDR.3 %02X\n", ret);

    jtag_data32(chip, 0, 0, 16);
    jtag_instruction(chip, FVFY1, 0);

    for (i=0; i<50; i++) {      /* mindestens 20 */
        ems_u32 v;
        jtag_data(chain, &v);
        dout +=v;
    }

    if ((ret=jtag_rd_data(chip, data, size)) != 0) {
        printf("\n");
        return ret;
    }
    jtag_rd_data(chip, 0, 0);

    return 0;
}
/****************************************************************************/
/****************************************************************************/
