Some remarks concerning INFN triggerboard:

Is "triggerboard" correct? I thought it is a "controller board"
controlling the trigger board and some other boards?

-----

proc_INFN_load and proc_INFN_load begin with

    ml_entry* module=ModulEnt(p[1]);
    struct vme_dev* dev=module->address.vme.dev;

ModulEnt is a macro defined as:

#define ModulEnt(n) \
    (memberlist?&modullist->entry[memberlist[n]]:&modullist->entry[n])

This has two consequences:
1:
If a IS-memberlist is defined p[1] will be the index into the memberlist
(starting with '1')
If a IS-memberlist is not defined p[1] will be the index into the modulelist
(starting with '0')
We defined (in stt_scaler.wad) an IS with a memberlist containing only this
module. Therefore the first argument of INFN_load must always be '1'

2:
ModulEnt(n) returns an invalid pointer if n (==p[1]) is not a valid index.
Therefore it is necessary to check p[1] inside the test procedure like this:

    ml_entry* module;
    if (!valid_module(p[1], modul_vme, 0))
        return plErr_ArgRange;
    module=ModulEnt(p[1]);
    if (module->modultype!=INFN_TRIGCONTR)
        return plErr_BadModTyp;

-----

Variables outside of procedures should be declared as 'static' in order
not to pollute the global name space.

-----

The EMS server is written in C. '//' are C++ comments. Not all compilers
tolerate this. We should at least try to write portable code.
(Do not assume that gcc is used as compiler.)

-----

The test procedures should set the variable 'wirbrauchen' (we_need) to the
number of words which the real procedure will return (maximum). It
exists in INFN_areg but is missing in INFN_load.
If it is REALLY impossible to determine the maximum amount of returned
data wirbrauchen should be set to -1. But then all error checks
(buffer sizes) are disabled. This is dangerous.

-----

The test procedure for INFN_areg is a little bit strange. It should be:

plerrcode test_proc_INFN_areg(ems_u32* p)
{
    if (p[0]<3 || p[0]>4)
        return plErr_ArgNum;
    if (!valid_module(p[1], modul_vme, 0))
        return plErr_ArgRange;
    if (ModulEnt(p[1])!=INFN_TRIGCONTR)
        return plErr_BadModTyp;
    wirbrauchen = 1;
    return plOK;
}

Returning plErr_System would be not correct here! plErr_System should only
be used if a system call (ioctl or read or so) fails. In this case errno
should be put on the outptr.

-----

The "else return(plErr_ArgRange);" in INFN_areg is unnecessary, it is checked
in the test procedure already.

-----

A loop like
    int i = 0;
    do {
        i++;
    } while (i<10000);
is useless.

Simple est program:

int main(int argc, char *argv[])
{
    int i = 0;
    do {
        i++;
    } while (i<10000);
    return i;
}

When compiled even with -O1 the result is
on Intel with gcc:

	.file	"empty_loop.c"
	.text
.globl main
	.type	main, @function
main:
	pushl	%ebp
	movl	%esp, %ebp
	movl	$10000, %eax
	popl	%ebp
	ret
	.size	main, .-main
	.ident	"GCC: (Ubuntu 4.4.1-4ubuntu8) 4.4.1"
	.section	.note.GNU-stack,"",@progbits

and on Alpha with native cc:

	.set noat
	.set noreorder
	.text
	.arch	generic
	.align 4
	.file 1 "empty_loop.c"
	.loc 1 1
 #      1 int main(int argc, char *argv[])
	.globl  main
	.ent 	main
	.loc 1 1
main:
	.frame  $sp, 0, $26
	.prologue 0
	.loc 1 7
 #      2 {
 #      3     int i = 0;
 #      4     do {
 #      5         i++;
 #      6     } while (i<10000);
 #      7     return i;
	.context full
	mov	10000, $0 # 000007
	.loc 1 8
 #      8 }
	ret	($26)     # 000008
	.end 	main
	.loc 1 1

I do not really understand the assembler code but it is very clear that just
10000 is returned without any loop. (There is no branch/jump inside the 
generated code.)

Only with -O0 the loop is really executed.

-----

The return code of VME reads and writes should be checked at better places.
In the actual code only the last access is checked. I would suggest to either
check it after every access or at least at the first access of each register.
If we want to be fast it seems to be acceptable to assume that a subsequent
access succeeds if the first acces was successfull.

-----

In proc_INFN_load plErr_ArgRange is returned if readBackValue is correct.
The error code should better be plErr_HW or plErr_Verify.
plErr_ArgRange should only be used if a value of an user supplied argument
is not acceptable.

-----

Each c-file should be start with a header like this:

/*
 * procs/unixvme/infn/INFN_triggerboard.c
 * created 2009-10-XX PB
 */
static const char* cvsid __attribute__((unused))=
    "$ZEL$";

The CVS will replace 'ZEL' with date and version ID. This signature can be
found in the compiled program using 'ident' (if it is not compiled
with -O3 :-( )

