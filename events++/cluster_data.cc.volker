/*
  * Code for reading cluster format provided by
  * Peter Wuestner, ZEL, FZJ
  *
  * Code adapted for use in RootSorter by VH:
  * - removed configuration option for different platforms
  * - removed certain references to global ems include files
  */

/*
 * ems/events++/cluster_data.cc
 * 
 * created 2006-Apr-28 PW
 */

#include "xdrstring.hh"
#include "cluster_data.hh"

#include <errno.h>
#include <iostream>
#include <iomanip>

using namespace std;

//***************************************************************************//
//ems_data

ems_data::ems_data(void)
:nr_texts(0), texts(0), nr_files(0), files(0), nr_skip_is(0), skip_is(0), 
allow_uncomplete(0),
smallest_ev_no(0), last_complete(0), nr_IS(0), IS_IDs(0), nr_VED(0),
VED_IDs(0), events(0), last_event(0), last_ved_event(0)
{}
//---------------------------------------------------------------------------//
ems_data::~ems_data()
{
    delete[] texts;
    delete[] files;
    delete[] IS_IDs;
    delete[] VED_IDs;
    delete[] events;
    delete[] skip_is;
}
//---------------------------------------------------------------------------//
int
ems_data::parse_timestamp(const ems_cluster *cluster, struct timeval *tv)
{
    tv->tv_sec=tv->tv_usec=0;
    ems_u32* options=cluster->data+3;

    if (options[0]==0) // no options exist
        return 0;
    if (!(options[1]&1)) // no timestamp
        return 0;
    tv->tv_sec=options[2];
    tv->tv_usec=options[3];
        return 0;
}
//---------------------------------------------------------------------------//
ems_data::event_info*
ems_data::find_ev_info(ems_u32 ev_no, int ved_idx)
{
    event_info *ev_info;

    if (last_ved_event[ved_idx])
        ev_info=last_ved_event[ved_idx];
    else
        ev_info=events;
    while (ev_info && (ev_info->ev_no<ev_no)) {
        ev_info=ev_info->next;
    }
    if ((ev_info!=0) && (ev_info->ev_no==ev_no)) {
        return ev_info;
    } else {
        return 0;
    }
}
//---------------------------------------------------------------------------//
int
ems_data::find_ved_idx(int VED_ID)
{
    for (int i=0; i<nr_VED; i++) {
        if (VED_IDs[i]==VED_ID)
            return i;
    }
    return -1;
}
//---------------------------------------------------------------------------//
int
ems_data::parse_cluster_events(const ems_cluster *cluster)
{
    ems_u32* p;
    int VED_ID;
    ems_u32 nr_events, ev_size, ev_no, ev_trigno, nr_subevents;

    // skip header, options and flags
    p=cluster->data+4+cluster->data[3]+1;
    VED_ID=*p++;
    p++; // skip unused fragment_id

    int ved_idx=find_ved_idx(VED_ID);
    if (ved_idx<0) {
        cerr<<"events from unknown VED "<<VED_ID<<endl;
        return -1;
    }
    if (ved_info.ved_infos[ved_idx].skip) return 0;
  
    nr_events=*p++;
    for (ems_u32 i=0; i<nr_events; i++) {
        event_info* ev_info;
        ems_event* event;
        ev_size=*p++;
        ev_no=*p++;
        ev_trigno=*p++;

        if (ev_no<smallest_ev_no) {
            cerr<<"unexpected event number "<<ev_no<<" (smaller than "
                <<smallest_ev_no<<")"<<endl;
            p += (ev_size-2);
	    continue;
        }
        ev_info=find_ev_info(ev_no, ved_idx);
        if (ev_info!=0) {
            event=ev_info->event;
        } else {
            event=new ems_event;
            event->event_nr=ev_no;
            event->trigger=ev_trigno;
            event->nr_subevents=0;
            event->subevents=0;
            ev_info=new event_info;
            ev_info->next=0;
            ev_info->complete=false;
            ev_info->veds=new bool[nr_VED];
            for (int j=0; j<nr_VED; j++) 
                ev_info->veds[j]=ved_info.ved_infos[j].skip;
            ev_info->ev_no=ev_no;
            ev_info->last_subevent=0;
            ev_info->event=event;
            
            if (last_event)
                last_event->next=ev_info;
            else
                events=ev_info;
            last_event=ev_info;
        }
        last_ved_event[ved_idx]=ev_info;

        ev_info->veds[ved_idx]=true;
        bool complete=true;
        for (int j=0; j<nr_VED; j++) {
            if (!ev_info->veds[j])
                complete=false;
        }
        if (complete) {
            ev_info->complete=complete;
            last_complete=ev_info->ev_no;
        }

        nr_subevents=*p++;
        for (ems_u32 j=0; j<nr_subevents; j++) {
            int IS_ID=*p++;
            int size=*p++;
            ems_u32* data=p;
            p+=size;

            ems_subevent* subevent=new ems_subevent;
            subevent->next=0;
            subevent->sev_id=IS_ID;
            subevent->size=size;
            subevent->data=new ems_u32[size];
            bcopy(data, subevent->data, size*sizeof(ems_u32));

            if (ev_info->last_subevent)
                ev_info->last_subevent->next=subevent;
            else
                event->subevents=subevent;
            ev_info->last_subevent=subevent;
            event->nr_subevents++;
        }
    }
    return 0;
}
//---------------------------------------------------------------------------//
int
ems_data::parse_cluster_file(const ems_cluster *cluster, ems_file** file)
{
    ems_u32* p;
    char* name;
    ems_file* ef;

    // skip header and options
    p=cluster->data+4+cluster->data[3];

    ems_u32 flags=*p++;
    ems_u32 fragment_id=*p++;
    p=xdrstrcdup(&name, p);

    if (fragment_id==0) {
        ef=new ems_file();
        ef->name=name;
        ef->ctime=*p++;
        ef->mtime=*p++;
        ef->mode=*p++;
        parse_timestamp(cluster, &ef->tv);
    } else {
        /* find existing file object with the same name */
        int i=0;
        while ((i<nr_files) && (files[i]->name==name))
            i++;
        if (i>=nr_files) {
            cerr<<"cannot find previous fragments of file "<<name<<endl;
            return -1;
        }
        ef=files[i];
        if (fragment_id!=ef->fragment+1) {
            cerr<<"file "<<name<<": fragment jumps from "<<ef->fragment
                <<" to "<<fragment_id<<endl;
            return -1;
        }
        ef->fragment=fragment_id;
        p+=3; // skip ctime, mtime, perm
    }
    p++; // skip redundant size info

    int osize=*p;
    char* s;
    p=xdrstrcdup(&s, p);
    if (fragment_id==0) {
        ef->content=string(s, osize);
    } else {
        ef->content.append(s, osize);
    }
    free(s);

    if (flags==1) 
        ef->complete=true;

    *file=ef;

    return fragment_id==0?0:1;
}
//---------------------------------------------------------------------------//
int
ems_data::parse_cluster_text(const ems_cluster *cluster, ems_text* text)
{
    ems_u32* p;
    int lnr;
    char* s;

    parse_timestamp(cluster, &text->tv);

    // skip header, options, flags, and fragment_id
    p=cluster->data+4+cluster->data[3]+2;

    text->nr_lines=*p++;
    if (text->nr_lines<1) {
        cerr<<"empty text cluster"<<endl;
        return -1;
    }

    text->lines=new string[text->nr_lines];

    p=xdrstrcdup(&s, p);
    text->lines[0]=s;
    free(s);
    if (text->lines[0].substr(0, 5)=="Key: ") {
        text->key=text->lines[0].substr(5, string::npos);
    }

    for (lnr=1; lnr<text->nr_lines; lnr++) {
        p=xdrstrcdup(&s, p);
        text->lines[lnr]=s;
        free(s);
        
    }

    return 0;
}
//---------------------------------------------------------------------------//
int
ems_data::parse_cluster_ved_info(const ems_cluster *cluster, ems_ved_info* info)
{
    ems_u32* p;
    parse_timestamp(cluster, &info->tv);

    // skip header and options
    p=cluster->data+4+cluster->data[3];
    info->version=*p++;

    switch (info->version) {
    case 0x80000001:
	{
	info->nr_veds=*p++;
        info->ved_infos=new ems_ved_info::ved_info[info->nr_veds];
        for (int i=0; i<info->nr_veds; i++) {
	    info->ved_infos[i].skip = false;
            info->ved_infos[i].VED_ID=*p++;
            info->ved_infos[i].nr_is=*p++;
            info->ved_infos[i].is_infos=
                    new ems_ved_info::is_info[info->ved_infos[i].nr_is];
            for (int j=0; j<info->ved_infos[i].nr_is; j++) {
	      int is   = *p++;
	      for (int c=0; c<nr_skip_is; c++) {
		if (is == skip_is[c]) {
		  cerr << "Skipping VED " << info->ved_infos[i].VED_ID
		       << " with IS " << is << endl;
		  info->ved_infos[i].skip = true;
		  break;
		}
	      }
	      info->ved_infos[i].is_infos[j].IS_ID=is;
	      info->ved_infos[i].is_infos[j].importance=0;
            }
        }
        info->valid=true;
        break;
	}
    case 0x80000002:
        cerr<<"ved info version 2 not yet implemented"<<endl;
        return -1;
        break;
    case 0x80000003:
        cerr<<"ved info version 3 not yet implemented"<<endl;
        return -1;
        break;
    default:
        cerr<<"unknown version of ved info: "<<hex<<showbase<<setw(8)
            <<setfill('0')<<info->version<<dec<<noshowbase<<setfill(' ')<<endl;
        return -1;
    }
    return 0;
}
//---------------------------------------------------------------------------//
int
ems_data::parse_cluster_no_more_data(const ems_cluster *cluster)
{
    cerr<<"no_more_data cluster received"<<endl;
    return 0;
}
//---------------------------------------------------------------------------//

int
ems_data::parse_cluster(const ems_cluster *cluster)
{
    int res;

    switch (cluster->type) {
    case clusterty_events:
        res=parse_cluster_events(cluster);
        break;
    case clusterty_ved_info:
        res=parse_cluster_ved_info(cluster, &ved_info);
        //ved_info.dump(0);
        nr_VED=ved_info.nr_veds;
        nr_IS=0;
        VED_IDs=new int[nr_VED];
        for (int i=0; i<nr_VED; i++) {
            VED_IDs[i]=ved_info.ved_infos[i].VED_ID;
            nr_IS+=ved_info.ved_infos[i].nr_is;
        }
        IS_IDs=new int[nr_IS];
        for (int i=0, is=0; i<nr_VED; i++) {
            for (int j=0; j<ved_info.ved_infos[i].nr_is; j++) {
                IS_IDs[is++]=ved_info.ved_infos[i].is_infos[j].IS_ID;
            }
        }
        last_ved_event = new event_info*[nr_VED];
        for (int i=0; i<nr_VED; i++)
                last_ved_event[i]=0;
        break;
    case clusterty_text: {
            ems_text* text=new ems_text();
            res=parse_cluster_text(cluster, text);
            if (res<0) {
                delete text;
            } else {
                ems_text** help=new ems_text*[nr_texts+1];
                for (int i=0; i<nr_texts; i++)
                    help[i]=texts[i];
                help[nr_texts]=text;
                delete[] texts;
                texts=help;
                nr_texts++;
            }
        }
        break;
    case clusterty_file: {
            ems_file* file;
            res=parse_cluster_file(cluster, &file);
            if (res==0) {
                ems_file** help=new ems_file*[nr_files+1];
                for (int i=0; i<nr_files; i++)
                    help[i]=files[i];
                help[nr_files]=file;
                delete[] files;
                files=help;
                nr_files++;
            }
        }
        break;
    case clusterty_no_more_data:
        res=parse_cluster_no_more_data(cluster);
        break;
    default:
        cerr<<"unknown clustertype "<<(int)cluster->type<<endl;
        res=-1;
    }
    return res;
}
//---------------------------------------------------------------------------//
void
ems_data::purge_uncomplete(void)
{
    // purge uncomplete events
    while (events && !events->complete && events->ev_no<last_complete) {
        //cerr<<"purge uncomplete event "<<events->ev_no<<endl;
        smallest_ev_no=events->ev_no+1;
        event_info* help=events->next;
        for (int i=0; i<nr_VED; i++) {
            if (last_ved_event[i]==events)
                last_ved_event[i]=0;
        }
        if (last_event==events)
            last_event=0;
        delete events->event;
        delete events->veds;
        delete events;
        events=help;
    }
}
//---------------------------------------------------------------------------//
bool
ems_data::events_available(void)
{
    purge_uncomplete();
    return events && events->complete;
}
//---------------------------------------------------------------------------//
int
ems_data::get_event(ems_event** eventp)
{
    purge_uncomplete();

    if (events && !events->complete && allow_uncomplete>0) {
      if (last_event && (last_event->ev_no - last_complete)>allow_uncomplete) {
	  // we have to do something
	  // assume the first event must be complete:
	  event_info* event = events;
	  for (int i=0; i<nr_VED; i++) {
	    if (!event->veds[i]) {
	      event->veds[i] = true;
	      ved_info.ved_infos[i].skip = true;
	      cerr << "Starting to skip VED ID " 
		   << ved_info.ved_infos[i].VED_ID << endl;
	    }
	  }
	  while ( (event = event->next) ) {
	    for (int i=0; i<nr_VED; i++) {
	      event->veds[i] |= ved_info.ved_infos[i].skip;
	    }
	  }
	}
    }
  
    if ( events && events->complete ) {

        *eventp=events->event;

        //cerr<<"purge event "<<events->ev_no<<" "<<(void*)events<<endl;
        smallest_ev_no=events->ev_no+1;
        event_info* help=events->next;
        for (int i=0; i<nr_VED; i++) {
            if (last_ved_event[i]==events)
                last_ved_event[i]=0;
        }
        if (last_event==events)
            last_event=0;
        delete events->veds;
        delete events;
        events=help;
        return 1;
    } else {
        return 0;
    }
}
//***************************************************************************//
static string
timestring(time_t t)
{
    static char ts[50];
    struct tm* tm;
    tm=localtime(&t);
    strftime(ts, 50, "%Y-%m-%d %H:%M:%S %Z", tm);
    return string(ts);
}
//***************************************************************************//
//ems_event

ems_event::~ems_event()
{
    while (subevents) {
        ems_subevent* help=subevents->next;
        delete subevents;
        subevents=help;
    }
}
//---------------------------------------------------------------------------//
void
ems_event::dump(int level) const
{
    cerr<<"event "<<event_nr<<" trigger "<<trigger<<endl;
    if (level>0) {
        cerr<<nr_subevents<<" subevents:";
        ems_subevent* sev=subevents;
        while (sev) {
            cerr<<" "<<sev->sev_id;
            sev=sev->next;
        }
        cerr<<endl;
    }
}
//***************************************************************************//
//ems_file

ems_file::ems_file()
:fragment(0), complete(false)
{}
//---------------------------------------------------------------------------//
ems_file::~ems_file()
{}
//---------------------------------------------------------------------------//
void
ems_file::dump(int level) const
{
    cerr<<"File: "<<name<<endl;
    if (level>0) {
        cerr<<"time stamp       : "<<timestring(tv.tv_sec)<<endl;
        cerr<<"creation time    : "<<timestring(ctime)<<endl;
        cerr<<"modification time: "<<timestring(mtime)<<endl;
        cerr<<"mode             : "<<oct<<showbase<<setw(8)<<setfill('0')
            <<mode<<dec<<noshowbase<<setfill(' ')<<endl;
        cerr<<content<<endl;
    }
}
//***************************************************************************//
//ems_text

ems_text::ems_text(void)
:nr_lines(0), lines(0)
{}
//---------------------------------------------------------------------------//
ems_text::~ems_text()
{}
//---------------------------------------------------------------------------//
void
ems_text::dump(int level) const
{
    cerr<<"Text: key="<<key<<", "<<nr_lines<<" lines"<<endl;
    if (level>0) {
        for (int i=0; i<nr_lines; i++)
            cerr<<lines[i]<<endl;
    }
}
//***************************************************************************//
//ems_ved_info

ems_ved_info::ems_ved_info(void)
:valid(false), nr_veds(0), ved_infos(0)
{}
//---------------------------------------------------------------------------//
ems_ved_info::~ems_ved_info()
{
    for (int i=0; i<nr_veds; i++) {
        delete[] ved_infos[i].is_infos;
    }
    delete[] ved_infos;
}
//---------------------------------------------------------------------------//
void
ems_ved_info::dump(int level) const
{
    cerr<<"VED info:"<<endl;
    for (int i=0; i<nr_veds; i++) {
        cerr<<"  VED "<<ved_infos[i].VED_ID<<endl;
        for (int j=0; j<ved_infos[i].nr_is; j++) {
            cerr<<"    IS "<<ved_infos[i].is_infos[j].IS_ID<<endl;
            if (ved_infos[i].is_infos[j].importance)
                cerr<<" ("<<ved_infos[i].is_infos[j].importance<<")";
            cerr<<endl;
        }
    }
}
//***************************************************************************//
//***************************************************************************//
