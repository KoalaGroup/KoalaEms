/*
 * emstcl.cc
 * created 01.09.95
 * 13.01.1999 PW: set_error_code used in all ems-calls
 * 16.07.1999 PW: for changed findstring adapted
 * 13.Nov.2000 PW: extern "C" for some procedures
 */

#include <tcl.h>

#ifdef USE_TK
#include <tk.h>
#endif

#include "config.h"
#if defined  (__STD_STRICT_ANSI) || defined (__STRICT_ANSI__)
#include <string>
#define STRING string
#else
#include <String.h>
#define USE_STRING_H
#define STRING String
#endif

#include <stdlib.h>
#include <unistd.h>
#include <proc_communicator.hxx>
#include <proc_veds.hxx>
#include <proc_is.hxx>
#include "emstcl_ved.hxx"
#include <errors.hxx>
#include "emstcl.hxx"
#include "findstring.hxx"
#include "chdel.hxx"
#include "ems_xdr.hxx"
#include <errorcodes.h>
#include <conststrings.h>
#include <reqstrings.h>
#include <clientcomm.h>
#include "compat.h"
#include <versions.hxx>

VERSION("Jul 16 1999", __FILE__, __DATE__, __TIME__)
static char* rcsid="$Id: emstcl.cc,v 1.22 2001/01/07 22:59:06 wuestner Exp $";
#define XVERSION

#ifdef HAVE_NAMESPACES
using namespace std;
#endif

/*****************************************************************************/

class globalcomm
  {
  public:
    globalcomm();
    Tcl_Interp* interp;
    STRING unsolcomm[NrOfUnsolmsg];
    STRING unknowncomm;
    int mtestpending;
//  Tcl_File commpath;
    int commpath;
  };

globalcomm::globalcomm()
{
for (int i=0; i<NrOfUnsolmsg; i++) unsolcomm[i]="";
mtestpending=0;
}

globalcomm global;

/******************************************************************************
*
* Ems_connect nimmt Kontakt zu einem Kommunikationsprozess auf.
*
* argv[1]: Socktname bzw. Hostname
* argv[2]: Portnummer
*
* Wenn eine globale Tcl-Variable ems_nocount definiert ist und einen Wert
* ungleich 0 enthaelt, wird dieser Client als Debug-Client betrachtet.
*/
extern "C" {
static int Ems_connect(ClientData clientdata, Tcl_Interp* interp, int argc,
    char* argv[])
{
char* var;
int ivar;

policies=pol_none;

var=Tcl_GetVar(interp, "ems_nodebug", TCL_GLOBAL_ONLY);
if (var && (Tcl_GetInt(interp, var, &ivar)==TCL_OK) && (ivar!=0))
  policies=(en_policies)(policies|pol_nodebug);

var=Tcl_GetVar(interp, "ems_noshow", TCL_GLOBAL_ONLY);
if (var && (Tcl_GetInt(interp, var, &ivar)==TCL_OK) && (ivar!=0))
  policies=(en_policies)(policies|pol_noshow);

var=Tcl_GetVar(interp, "ems_nocount", TCL_GLOBAL_ONLY);
if (var && (Tcl_GetInt(interp, var, &ivar)==TCL_OK) && (ivar!=0))
  policies=(en_policies)(policies|pol_nocount);

var=Tcl_GetVar(interp, "ems_nowait", TCL_GLOBAL_ONLY);
if (var && (Tcl_GetInt(interp, var, &ivar)==TCL_OK) && (ivar!=0))
  policies=(en_policies)(policies|pol_nowait);

try
  {
  switch (argc)
    {
    case 1:
      communication.init();
      break;
    case 2:
      communication.init(argv[1]);
      break;
    case 3:
      {
      int port;
      if (Tcl_GetInt(interp, argv[2], &port)!=TCL_OK) return TCL_ERROR;
      communication.init(argv[1], port);
      }
      break;
    default:
      Tcl_SetResult(interp, "wrong # args; must be [socket] | [host port]",
          TCL_STATIC);
      return TCL_ERROR;
    }
  }
catch (C_error* e)
  {
  ostrstream s;
  s << (*e) << ends;
  Tcl_SetResult(interp, s.str(), ch_del);
  set_error_code(interp, e);
  delete e;
  return TCL_ERROR;
  }
return TCL_OK;
}}
/******************************************************************************
*
* Ems_disconnect bricht den Kontakt zu einem Kommunikationsprozess ab.
*
*/
extern "C" {
static int Ems_disconnect(ClientData clientdata, Tcl_Interp* interp, int argc,
    char* argv[])
{
if (argc!=1)
  {
  Tcl_SetResult(interp, "wrong # args; no args expected", TCL_STATIC);
  return TCL_ERROR;
  }
try
  {
  communication.done();
  }
catch (C_error* e)
  {
  ostrstream s;
  s << (*e) << ends;
  Tcl_SetResult(interp, s.str(), ch_del);
  set_error_code(interp, e);
  delete e;
  return TCL_ERROR;
  }
return TCL_OK;
}}
/******************************************************************************
*
* Ems_connected testet den Kontakt zu einem Kommunikationsprozess.
*
*/
extern "C" {
static int Ems_connected(ClientData clientdata, Tcl_Interp* interp, int argc,
    char* argv[])
{
if (argc!=1)
  {
  Tcl_SetResult(interp, "wrong # args; no args expected", TCL_STATIC);
  return TCL_ERROR;
  }

if (communication.valid())
  Tcl_SetResult(interp, "1", TCL_STATIC);
else
  Tcl_SetResult(interp, "0", TCL_STATIC);
return TCL_OK;
}}
/******************************************************************************
*
* Ems_connection gibt die Verbindung eines Kommunikationsprozesses an.
*
*/
extern "C" {
static int Ems_connection(ClientData clientdata, Tcl_Interp* interp, int argc,
    char* argv[])
{
if (argc!=1)
  {
  Tcl_SetResult(interp, "wrong # args; no args expected", TCL_STATIC);
  return TCL_ERROR;
  }

ostrstream ss;
ss << communication << ends;
Tcl_SetResult(interp, ss.str(), ch_del);
return TCL_OK;
}}
/******************************************************************************
*
* Ems_veds liefert eine Liste der verfuegbaren veds
* Argumente: keine
* Resultat: VED-Liste
*/
extern "C" {
static int Ems_veds(ClientData clientdata, Tcl_Interp* interp, int argc,
    char* argv[])
{
if (argc!=1)
  {
  Tcl_SetResult(interp, "wrong # args; no args expected", TCL_STATIC);
  return TCL_ERROR;
  }

C_VED* commu=0;
C_instr_system* commu_is;
try
  {
  commu=new C_VED("commu");
  commu_is=commu->is0();
  if (commu_is==0)
    {
    throw new C_program_error("commu hat kein IS 0");
    }
  commu->confmode(synchron);
  C_confirmation* conf;
  conf=commu_is->command("VEDnames");
  C_inbuf inbuf(conf->buffer(), conf->size());
  delete conf;
  inbuf++;
  int num;
  inbuf >> num;
  for (int i=0; i<num; i++)
    {
    STRING s;
    inbuf >> s;
#ifdef USE_STRING_H
    Tcl_AppendElement(interp, (char*)(const char*)s);
#else
    Tcl_AppendElement(interp, (char*)(s.c_str()));
#endif
    }
  delete commu;
  }
catch(C_error* e)
  {
  ostrstream s;
  s << (*e) << ends;
  Tcl_SetResult(interp, s.str(), ch_del);
  set_error_code(interp, e);
  delete e;
  delete commu;
  return TCL_ERROR;
  }
return TCL_OK;
}}
/******************************************************************************
*
* Ems_open oeffnet ein VED
*
* Argumente: VED-Name [prior]
* Result   : VED-Name
* Nebeneffekte: Es wird ein Commando ved_$VED-Name erzeugt
*/
extern "C" {
static int Ems_open(ClientData clientdata, Tcl_Interp* interp, int argc,
    char* argv[])
{
if (argc!=2)
  {
  Tcl_SetResult(interp, "wrong # args; must be VED-Name", TCL_STATIC);
  return TCL_ERROR;
  }
C_VED::VED_prior prior=C_VED::NO_prior;
if (argc==3)
  {
  int v;
  if (Tcl_GetInt(interp, argv[2], &v)!=TCL_OK) return TCL_ERROR;
  prior=(C_VED::VED_prior)v;
  }

E_ved* ved;
try
  {
  ved=new E_ved(interp, argv[1], prior);
  }
catch (C_error* e)
  {
  ostrstream s;
  s << (*e) << ends;
  Tcl_SetResult(interp, s.str(), ch_del);
  set_error_code(interp, e);
  delete e;
  return TCL_ERROR;
  }
ved->create_tcl_proc();
return TCL_OK;
}}
/******************************************************************************
*
* Ems_openveds liefert eine Liste der VED-Kommandos aller geoeffneten VEDs
*
*/
extern "C" {
static int Ems_openveds(ClientData clientdata, Tcl_Interp* interp, int argc,
    char* argv[])
{
if (argc!=1)
  {
  Tcl_SetResult(interp, "no args expected", TCL_STATIC);
  return TCL_ERROR;
  }

for (int i=0; i<eveds.count(); i++)
#ifdef USE_STRING_H
  Tcl_AppendElement(interp, (char*)(const char*)eveds[i]->tclprocname());
#else
  Tcl_AppendElement(interp, (char*)(eveds[i]->tclprocname().c_str()));
#endif
return TCL_OK;
}}
/******************************************************************************
*
* Ems_unsolcommand installiert eine Callbackfunktion fuer unsolicited Messages
* vom Kommunikationsprozess.
*
* argv[1]: TCL_Kommando
*          %h wird durch den Header, %d durch die Daten ersetzt
*          falls type gleich ServerDisconnect ist, wird %v durch das
*          VED-Kommando ersetzt
*/
extern "C" {
static int Ems_unsolcommand(ClientData clientdata, Tcl_Interp* interp, int argc,
    char* argv[])
{
// ems_unsolcommand type [command]
if ((argc<2) || (argc>3))
  {
  Tcl_SetResult(interp, "wrong # args; must be type [tcl_command]", TCL_STATIC);
  return TCL_ERROR;
  }
int type, res;
switch (res=findstring(interp, argv[1], unsolstrs, /*NrOfUnsolmsg,*/ &type))
  {
  case -1: // nicht gefunden
    return TCL_ERROR;
  case -2: // war integer
    break;
  default:
    type=res;
    break;
  }

#ifdef USE_STRING_H
Tcl_SetResult(interp, (char*)(const char*)global.unsolcomm[type], TCL_VOLATILE);
#else
Tcl_SetResult(interp, (char*)global.unsolcomm[type].c_str(), TCL_VOLATILE);
#endif
if (argc==2)
  global.unsolcomm[type]="";
else
  global.unsolcomm[type]=argv[2];
return TCL_OK;
}}
/******************************************************************************
*
* Ems_confmodecommand setzt einen Default-Wert fuer den Confirmationmode. 
* Alle neu geoffneten VEDs uebernehmen diesen.
* wenn '-all' angegeben ist, uebernehmen ihn auch geoeffnete VEDs.
* Ganz ohne Argumente tut es nichts.
* Rueckgabe ist der vorherige Modus.
* Nach Programmstart steht er auf 'synchron' (in proc_ved.cc festgelegt).
*/
extern "C" {
static int Ems_confmodecommand(ClientData clientdata, Tcl_Interp* interp,
    int argc, char* argv[])
{
// ems_confmodecommand [[-all] synchron|asynchron]
if (argc>3)
  {
  Tcl_SetResult(interp, "wrong # args; must be [[-all] synchron|asynchron]",
      TCL_STATIC);
  return TCL_ERROR;
  }
conf_mode oldmode;
if (argc==1)
  {
  oldmode=veds.def_confmode();
  }
else
  {
  int all=0;
  char* arg=argv[1];
  conf_mode mode;
  if (argc==3)
    {
    if (strcmp(argv[1], "-all")!=0)
      {
      Tcl_SetResult(interp, "wrong args; must be [[-all] synchron|asynchron]",
          TCL_STATIC);
      return TCL_ERROR;
      }
    all=1;
    arg=argv[2];
    }
  const char* names[]={
    "synchron",
    "asynchron",
    0};
  switch (findstring(interp, arg, names))
    {
    case 0: mode=synchron; break;
    case 1: mode=asynchron; break;
    default: return TCL_ERROR;
    }
  if (all)
    {
    oldmode=veds.def_confmode();
    veds.set_confmode(mode);
    }
  else
    oldmode=veds.def_confmode(mode);
  }
Tcl_SetResult(interp, (char*)(oldmode==synchron?"synchron":"asynchron"),
    TCL_STATIC);
return TCL_OK;
}}
/*****************************************************************************/
extern "C" {
void E_veds_timerdummy(ClientData)
{
cerr << "E_veds::timerdummy called" << endl;
}}
/*****************************************************************************/

int E_veds::pending(void) const
{
int num=0;
for (int i=0; i<count(); i++)
  num+=list[i]->confbacknum();
return num;
}

/******************************************************************************
*
* Ems_pendingcommand stellt fest, wieviele Confirmations noch erwartet werden.
*/
extern "C" {
static int Ems_pendingcommand(ClientData clientdata, Tcl_Interp* interp,
    int argc, char* argv[])
{
// ems_pendingcommand
if (argc>1)
  {
  Tcl_SetResult(interp, "no args expected", TCL_STATIC);
  return TCL_ERROR;
  }
ostrstream st(interp->result, TCL_RESULT_SIZE);
st << eveds.pending() << ends;
return TCL_OK;
}}
/******************************************************************************
*
* Ems_flushcommand wartet, bis alle Confirmations eingesammelt sind, bricht
* jedoch nach Ablauf eines Timeouts ab.
* Gibt die Anzahl noch fehlender Confirmations zurueck.
*/
extern "C" {
static int Ems_flushcommand(ClientData clientdata, Tcl_Interp* interp,
    int argc, char* argv[])
{
// ems_flushcommand [timeout]
if (argc>2)
  {
  Tcl_SetResult(interp, "wrong # args; must be flush [timeout/ms]", TCL_STATIC);
  return TCL_ERROR;
  }
struct timeval start, jetzt;
int timeout=0, msec;
Tcl_TimerToken token;
if ((argc>1) && (Tcl_GetInt(interp, argv[1], &timeout)!=TCL_OK))
    return TCL_ERROR;
if (timeout)
  {
  gettimeofday(&start, 0);
  token=Tcl_CreateTimerHandler(timeout, E_veds_timerdummy, 0);
  }
int num, nochzeit=1;
while (((num=eveds.pending())>0) && nochzeit)
  {
  Tcl_DoOneEvent(TCL_ALL_EVENTS);
  if (timeout)
    {
    gettimeofday(&jetzt, 0);
    msec=(jetzt.tv_usec-start.tv_usec)/1000+(jetzt.tv_sec-start.tv_sec)*1000;
    nochzeit=msec<timeout;
    }
  }
if (timeout) Tcl_DeleteTimerHandler(token);
ostrstream st(interp->result, TCL_RESULT_SIZE);
st << num << ends;
return TCL_OK;
}}
/******************************************************************************
*
* Ems_timeoutcommand legt einen Timeout fuer Confirmations fest
*
*/
extern "C" {
static int Ems_timeoutcommand(ClientData clientdata, Tcl_Interp* interp,
    int argc, char* argv[])
{
if (argc>2)
  {
  Tcl_SetResult(interp, "wrong # args; must be timeout [timeout/sec]",
      TCL_STATIC);
  return TCL_ERROR;
  }
int to;
if (argc>1)
  {
  int nto;
  if (Tcl_GetInt(interp, argv[1], &nto)!=TCL_OK) return TCL_ERROR;
  to=communication.deftimeout(nto);
  }
else
  to=communication.deftimeout();
ostrstream st(interp->result, TCL_RESULT_SIZE);
st << to << ends;
return TCL_OK;
}}
/*****************************************************************************/

static void printunsol(Tcl_Interp* interp, C_confirmation* conf)
{
ostrstream ss;
msgheader* header=conf->header();
ss << "got message:" << endl
  << "  size  :" << header->size << endl
  << "  client:" << header->client << endl
  << "  ved   :" << header->ved << endl
  << "  type  :" << header->type.reqtype << endl
  << "  flags :" << header->flags << endl
  << "  xid   :" << header->transid << ends;
Tcl_SetResult(interp, ss.str(), ch_del);
Tcl_BackgroundError(interp);
}

/*****************************************************************************/

static char* unpackheader(C_confirmation* conf)
{
ostrstream ss;
msgheader* header=conf->header();
ss << '{' << header->size << ' '
    << header->client << ' '
    << header->ved << ' '
    << header->type.reqtype << ' '
    << header->flags << ' '
    << header->transid << '}' << ends;
return ss.str();
}

/*****************************************************************************/

static char* unpackbody(C_confirmation* conf)
{
ostrstream ss;
int size=conf->header()->size;
ss << '{';
for (int i=0; i<size; i++)
  {
  if (i>0) ss << ' ';
  ss << conf->buffer(i);
  }
ss << '}' << ends;
return ss.str();
}

/*****************************************************************************/

static void dispatchunsol(Tcl_Interp* interp, C_confirmation* conf)
{
msgheader* header=conf->header();
if ((header->flags & Flag_Unsolicited)==0) // normale confirmation
  {
  E_ved* ved=eveds.find(header->ved);
  if (!ved)
    {
    ostrstream ss;
    ss << "confirmation from unknown ved " << header->ved << ends;
    Tcl_SetResult(interp, ss.str(), ch_del);
    Tcl_BackgroundError(interp);
    }
  else
    {
    E_ved::confbackentry* entry;
    if ((entry=ved->extractconfback(header->transid))==0)
      {
      ostrstream ss;
      ss << "no callback for ved " << ved->tclprocname() << endl
          << "  xid     : " << header->transid << endl
          << "  size    : " << header->size << endl
          << "  request : " << Req_str(header->type.reqtype) << ends;
      Tcl_SetResult(interp, ss.str(), ch_del);
      Tcl_BackgroundError(interp);
      }
    else
      {
      ostrstream ss;
      int err=TCL_OK;
      if ((conf->size()<1) || (conf->buffer(0)!=OK)) // Ems-Fehler
        {
        if (entry->err_command==0)
          ss << "ems_async_error ";
        else
          ss << Tcl_DStringValue(entry->err_command) << " ";
        ss << E_confirmation::new_E_confirmation(interp, ved, *conf) << ends;
        }
      else // Ems Ok
        {
        if (entry->ok_command==0)
          ss << "ems_async_ok ";
        else
          ss << Tcl_DStringValue(entry->ok_command) << " ";
        try
          {
          //cerr << "call former " << ved->formername(entry->form) << endl;
          err=(ved->*(entry->form))(ss, conf, !entry->former_default,
              entry->numformargs, entry->formargs);
          }
        catch(C_error* error)
          {
          ostrstream ss;
          ss << (*error) << ends;
          Tcl_SetResult(interp, ss.str(), ch_del);
          set_error_code(interp, error);
          delete error;
          err=TCL_ERROR;
          }
        if (err!=TCL_OK)
          {
          ostrstream ss;
          ss << endl << "former '" << ved->formername(entry->form)
              << "' called from callback for ved " << ved->name()
              << " (" << ved->tclprocname() << ") " << ", xid "
              << header->transid << ends;
          char* s=ss.str();
          Tcl_AddErrorInfo(interp, s);
          delete[] s;
          }
        }
      char* s=ss.str();
      if (err==TCL_OK) 
        {
        if ((err=Tcl_GlobalEval(interp, s))!=TCL_OK)
          {
          ostrstream ss;
          ss << endl << "called from callback for ved " << ved->name()
              << " (" << ved->tclprocname() << ") "
              << ", xid " << header->transid << ends;
          char* s=ss.str();
          Tcl_AddErrorInfo(interp, s);
          delete[] s;
          }
        }
      if (err!=TCL_OK) Tcl_BackgroundError(interp);
      delete[] s;
      delete entry;
      }
    }
  }
else // unsolicited message
  {
  if ((header->ved==EMS_commu) || (header->flags&Flag_IdGlobal))
    { // Message kommt von commu oder mit globalem ID
    if (global.unsolcomm[header->type.reqtype]!="") // callback vorhanden
      {
      STRING st;
      int x;
      st=global.unsolcomm[header->type.reqtype];

#ifdef USE_STRING_H
      if ((x=st.index(STRING("%h")))>=0)        // header in Kommando einpacken
#else
      if ((x=st.find("%h"))!=string::npos)      // header in Kommando einpacken
#endif
        {
        char *s=unpackheader(conf);
#ifdef USE_STRING_H
        do
          st=st(0, x)+s+st(x+2, st.length()-x-2);
        while ((x=st.index(STRING("%h")))>=0);
#else
        do
          st=st.substr(0, x)+s+st.substr(x+2, string::npos);
        while ((x=st.find("%h"))!=string::npos);
#endif
        delete[] s;
        }
#ifdef USE_STRING_H
      if ((x=st.index(STRING("%d")))>=0)        // Daten in Kommando einpacken
#else
      if ((x=st.find("%d"))!=string::npos)      // Daten in Kommando einpacken
#endif
        {
        char *s=unpackbody(conf);
#ifdef USE_STRING_H
        do
          st=st(0, x)+s+st(x+2, st.length()-x-2);
        while ((x=st.index(STRING("%d")))>=0);
#else
        do
          st=st.substr(0, x)+s+st.substr(x+2, string::npos);
        while ((x=st.find("%d"))!=string::npos);
#endif
        delete[] s;
        }
#ifdef USE_STRING_H
      if ((header->type.reqtype==Unsol_ServerDisconnect) && // VED-Name in
          ((x=st.index(STRING("%v")))>=0))       // Kommando einpacken
#else
      if ((header->type.unsoltype==Unsol_ServerDisconnect) && // VED-Name in
          ((x=st.find("%v"))!=string::npos))     // Kommando einpacken
#endif
        {                                        // (wenn moeglich)
        STRING s;
        E_ved* ved=eveds.find(conf->buffer(0));
        if (ved)
          s=ved->tclprocname();
        else
          s="unknown_ved";
#ifdef USE_STRING_H
        do
          st=st(0, x)+s+st(x+2, st.length()-x-2);
        while ((x=st.index(STRING("%v")))>=0);
#else
        do
          st=st.substr(0, x)+s+st.substr(x+2, string::npos);
        while ((x=st.find("%v"))!=string::npos);
#endif
        }
#ifdef USE_STRING_H
      if (Tcl_GlobalEval(global.interp, (char*)(const char*)st)!=TCL_OK)
#else
      if (Tcl_GlobalEval(global.interp, (char*)st.c_str())!=TCL_OK)
#endif
          Tcl_BackgroundError(interp);
      }
    else if (header->type.unsoltype==Unsol_ServerDisconnect)
      {
      ostrstream ss;
      ss << "server " << conf->buffer(0) << " starb." << ends;
      Tcl_SetResult(interp, ss.str(), ch_del);
      Tcl_BackgroundError(interp);
  //    cerr << "server " << conf->buffer(0) << " starb." << endl;
      }
    else if (header->type.unsoltype==Unsol_Bye)
      {
      try {communication.done();} catch (...) {}
      }
    else
      printunsol(interp, conf); // Notloesung
    }
  else // Message kommt von "richtiger" VED
    {
    E_ved* ved=eveds.find(header->ved);
    if (!ved)
      printunsol(interp, conf); // Notloesung, wenn VED nicht mehr offen
    else
      {
      STRING st;
      int x;
      if ((header->type.unsoltype>0) && (header->type.unsoltype<NrOfUnsolmsg)
          && (ved->unsolcomm[header->type.unsoltype]!=""))
        st=ved->unsolcomm[header->type.unsoltype];
      else
        st=ved->defunsolcomm;
#ifdef USE_STRING_H
      if ((x=st.index(STRING("%h")))>=0)
#else
      if ((x=st.find("%h"))!=string::npos)
#endif
        {
        char *s=unpackheader(conf);
#ifdef USE_STRING_H
        do
          st=st(0, x)+s+st(x+2, st.length()-x-2);
        while ((x=st.index(STRING("%h")))>=0);
#else
        do
          st=st.substr(0, x)+s+st.substr(x+2, string::npos);
        while ((x=st.find("%h"))!=string::npos);
#endif
        delete[] s;
        }
#ifdef USE_STRING_H
      if ((x=st.index(STRING("%d")))>=0)
#else
      if ((x=st.find("%d"))!=string::npos)
#endif
        {
        char *s=unpackbody(conf);
#ifdef USE_STRING_H
        do
          st=st(0, x)+s+st(x+2, st.length()-x-2);
        while ((x=st.index(STRING("%d")))>=0);
#else
        do
          st=st.substr(0, x)+s+st.substr(x+2, string::npos);
        while ((x=st.find("%d"))!=string::npos);
#endif
        delete[] s;
        }
#ifdef USE_STRING_H
      if ((x=st.index(STRING("%v")))>=0)
#else
      if ((x=st.find("%v"))!=string::npos)
#endif
        {
        STRING s;
        s=ved->tclprocname();
#ifdef USE_STRING_H
        do
          st=st(0, x)+s+st(x+2, st.length()-x-2);
        while ((x=st.index(STRING("%v")))>=0);
#else
        do
          st=st.substr(0, x)+s+st.substr(x+2, string::npos);
        while ((x=st.find("%v"))!=string::npos);
#endif
        }
#ifdef USE_STRING_H
      if (Tcl_GlobalEval(global.interp, (char*)(const char*)st)!=TCL_OK) Tcl_BackgroundError(interp);
#else
      if (Tcl_GlobalEval(global.interp, (char*)st.c_str())!=TCL_OK) Tcl_BackgroundError(interp);
#endif
      }
    }
  }
delete conf;
}

/*****************************************************************************/
extern "C" {
static void commpathback(ClientData data, int mask)
{
Tcl_Interp* interp=(Tcl_Interp*)data;
if (interp==0)
  {
  cerr << "commpathback: interp=0" << endl;
  sleep(2);
  int x=*(int*)0;
  cerr << "x=" << x << endl;
  }
if (mask & TCL_EXCEPTION)
  {
  ostrstream ss;
  ss << "commpathback: exception: " << mask << ends;
  Tcl_SetResult(interp, ss.str(), ch_del);
  Tcl_BackgroundError(interp);
  }
if (mask & TCL_READABLE)
  {
  struct timeval tv;
  tv.tv_sec=0; tv.tv_usec=0;
  C_confirmation* conf;
  try
    {
    conf=communication.GetConf(&tv);
    }
  catch (C_error* e)
    {
    Tcl_DeleteFileHandler(global.commpath);
    ostrstream ss;
    ss << (*e) << ends;
    Tcl_SetResult(interp, ss.str(), ch_del);
    Tcl_BackgroundError(interp);
    conf=0;
    }
  if (conf!=0) dispatchunsol(interp, conf);
  }
}
}
/*****************************************************************************/
extern "C" {
static void idleback(ClientData data)
{
Tcl_Interp* interp=(Tcl_Interp*)data;
if (interp==0)
  {
  cerr << "idleback: interp=0" << endl;
  sleep(2);
  int x=*(int*)0;
  cerr << "x=" << x << endl;
  }
global.mtestpending=0;
struct timeval tv;
tv.tv_sec=0; tv.tv_usec=0;
C_confirmation* conf=communication.GetConf(&tv);
if (conf!=0) dispatchunsol(interp, conf);
}}
/*****************************************************************************/

static void messageback(ClientData data)
{
Tcl_Interp* interp=(Tcl_Interp*)data;
if (interp==0)
  {
  cerr << "idleback: interp=0" << endl;
  sleep(2);
  int x=*(int*)0;
  cerr << "x=" << x << endl;
  }
if (!global.mtestpending)
  {
  Tcl_DoWhenIdle(idleback, interp);
  global.mtestpending=1;
  }
}

/*****************************************************************************/
extern "C" {
static void emsexit(ClientData)
{
try
  {
  communication.done();
  }
catch (C_error* e)
  {
  cerr << (*e) << endl;
  delete e;
  }
}
}
/*****************************************************************************/

static void commuback(ClientData data, int action, int reason, int path)
{
// action == -1: abort
//            0: close
//            1: open
Tcl_Interp* interp=(Tcl_Interp*)data;
if (interp==0)
  {cerr << "commuback: interp=0" << endl;
  sleep(2);
  int x=*(int*)0;
  cerr << "x=" << x << endl;
  }
switch (action)
  {
  case -1:
    {
    ostrstream st;
    st << "Communication aborted: error " << reason << endl;
    Tcl_DeleteExitHandler(emsexit, 0);
    Tcl_DeleteFileHandler(global.commpath);
//  Tcl_FreeFile(global.commpath);
    Tcl_SetResult(interp, st.str(), ch_del);
    Tcl_BackgroundError(interp);
    }
    break;
  case 0:
    Tcl_DeleteExitHandler(emsexit, 0);
    Tcl_DeleteFileHandler(global.commpath);
//  Tcl_FreeFile(global.commpath);
    break;
  case 1:
    Tcl_CreateExitHandler(emsexit, 0);
//  global.commpath=Tcl_GetFile((ClientData)path, TCL_UNIX_FD);
    global.commpath=path;
    Tcl_CreateFileHandler(global.commpath, TCL_READABLE| TCL_EXCEPTION,
        commpathback, (ClientData)interp);
    break;
  }
}

/*****************************************************************************/
extern "C" {
int Ems_Init(Tcl_Interp* interp)
{

Tcl_CreateCommand(interp, "ems_connect", Ems_connect, ClientData(0),
    (Tcl_CmdDeleteProc*)0);

Tcl_CreateCommand(interp, "ems_disconnect", Ems_disconnect, ClientData(0),
    (Tcl_CmdDeleteProc*)0);

Tcl_CreateCommand(interp, "ems_connected", Ems_connected, ClientData(0),
    (Tcl_CmdDeleteProc*)0);

Tcl_CreateCommand(interp, "ems_connection", Ems_connection,
    ClientData(0), (Tcl_CmdDeleteProc*)0);

Tcl_CreateCommand(interp, "ems_open", Ems_open, ClientData(0),
    (Tcl_CmdDeleteProc*)0);

Tcl_CreateCommand(interp, "ems_veds", Ems_veds, ClientData(0),
    (Tcl_CmdDeleteProc*)0);

Tcl_CreateCommand(interp, "ems_openveds", Ems_openveds, ClientData(0),
    (Tcl_CmdDeleteProc*)0);

Tcl_CreateCommand(interp, "ems_unsolcommand", Ems_unsolcommand, ClientData(0),
    (Tcl_CmdDeleteProc*)0);

Tcl_CreateCommand(interp, "ems_confmode", Ems_confmodecommand, ClientData(0),
    (Tcl_CmdDeleteProc*)0);

Tcl_CreateCommand(interp, "ems_pending", Ems_pendingcommand, ClientData(0),
    (Tcl_CmdDeleteProc*)0);

Tcl_CreateCommand(interp, "ems_flush", Ems_flushcommand, ClientData(0),
    (Tcl_CmdDeleteProc*)0);

Tcl_CreateCommand(interp, "ems_timeout", Ems_timeoutcommand, ClientData(0),
    (Tcl_CmdDeleteProc*)0);

Tcl_CreateObjCommand(interp, "xdr2float", XDR2floatcommand, ClientData(0),
    (Tcl_CmdDeleteProc*)0);

Tcl_CreateObjCommand(interp, "float2xdr", float2XDRcommand, ClientData(0),
    (Tcl_CmdDeleteProc*)0);

Tcl_CreateObjCommand(interp, "xdr2double", XDR2doublecommand, ClientData(0),
    (Tcl_CmdDeleteProc*)0);

Tcl_CreateObjCommand(interp, "double2xdr", double2XDRcommand, ClientData(0),
    (Tcl_CmdDeleteProc*)0);

Tcl_CreateObjCommand(interp, "xdr2string", XDR2stringcommand, ClientData(0),
    (Tcl_CmdDeleteProc*)0);

Tcl_CreateObjCommand(interp, "string2xdr", string2XDRcommand, ClientData(0),
    (Tcl_CmdDeleteProc*)0);

global.interp=interp;
communication.installpcallback(commuback, ClientData(interp));
communication.installmcallback(messageback, ClientData(interp));
return TCL_OK;
}}
/*****************************************************************************/
/*****************************************************************************/
